From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Thu, 19 Nov 2020 21:30:00 +0100
Subject: [PATCH 1/2] Reuse Arm intrinsics for WebAssembly

Upstream-Status: Pending

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -62,7 +62,13 @@ foreach(ARCH ${CMAKE_OSX_ARCHITECTURES})
   endif()
   math(EXPR COUNT "${COUNT}+1")
 endforeach()
-if(CMAKE_SYSTEM_PROCESSOR_LC MATCHES "x86_64" OR
+if(EMSCRIPTEN)
+  if(BITS EQUAL 64)
+    set(CPU_TYPE wasm64)
+  else()
+    set(CPU_TYPE wasm32)
+  endif()
+elseif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES "x86_64" OR
   CMAKE_SYSTEM_PROCESSOR_LC MATCHES "amd64" OR
   CMAKE_SYSTEM_PROCESSOR_LC MATCHES "i[0-9]86" OR
   CMAKE_SYSTEM_PROCESSOR_LC MATCHES "x86" OR
diff --git a/simd/CMakeLists.txt b/simd/CMakeLists.txt
index 1111111..2222222 100644
--- a/simd/CMakeLists.txt
+++ b/simd/CMakeLists.txt
@@ -211,7 +211,8 @@ endif()
 # Arm (Intrinsics or GAS)
 ###############################################################################
 
-elseif(CPU_TYPE STREQUAL "arm64" OR CPU_TYPE STREQUAL "arm")
+elseif(CPU_TYPE STREQUAL "arm64" OR CPU_TYPE STREQUAL "arm" OR
+  CPU_TYPE STREQUAL "wasm64" OR CPU_TYPE STREQUAL "wasm32")
 
 # If Neon instructions are not explicitly enabled at compile time (e.g. using
 # -mfpu=neon) with an AArch32 Linux or Android build, then the AArch32 SIMD
@@ -224,7 +225,7 @@ elseif(CPU_TYPE STREQUAL "arm64" OR CPU_TYPE STREQUAL "arm")
 # following test determines whether -mfloat-abi=softfp should be explicitly
 # added to the compile flags for the intrinsics implementation of the Neon SIMD
 # extensions.
-if(BITS EQUAL 32)
+if(BITS EQUAL 32 AND NOT EMSCRIPTEN)
   check_c_source_compiles("
     #if defined(__ARM_NEON__) || (!defined(__linux__) && !defined(ANDROID) && !defined(__ANDROID__))
     #error \"Neon run-time auto-detection will not be used\"
@@ -242,7 +243,7 @@ if(BITS EQUAL 32)
 endif()
 
 include(CheckSymbolExists)
-if(BITS EQUAL 32)
+if(BITS EQUAL 32 OR EMSCRIPTEN)
   set(CMAKE_REQUIRED_FLAGS "-mfpu=neon ${SOFTFP_FLAG}")
   check_c_source_compiles("
     #include <arm_neon.h>
@@ -259,7 +260,7 @@ endif()
 check_symbol_exists(vld1_s16_x3 arm_neon.h HAVE_VLD1_S16_X3)
 check_symbol_exists(vld1_u16_x2 arm_neon.h HAVE_VLD1_U16_X2)
 check_symbol_exists(vld1q_u8_x4 arm_neon.h HAVE_VLD1Q_U8_X4)
-if(BITS EQUAL 32)
+if(BITS EQUAL 32 OR EMSCRIPTEN)
   unset(CMAKE_REQUIRED_FLAGS)
 endif()
 configure_file(arm/neon-compat.h.in arm/neon-compat.h @ONLY)
@@ -270,9 +271,9 @@ include_directories(${CMAKE_CURRENT_BINARY_DIR}/arm)
 # those compilers, we default to using the older GAS implementation of the Neon
 # SIMD extensions for certain algorithms.  The presence or absence of the three
 # intrinsics we tested above is a reasonable proxy for this.  We always default
-# to using the full Neon intrinsics implementation when building for macOS or
-# iOS, to avoid the need for gas-preprocessor.
-if((HAVE_VLD1_S16_X3 AND HAVE_VLD1_U16_X2 AND HAVE_VLD1Q_U8_X4) OR APPLE)
+# to using the full Neon intrinsics implementation when building for macOS, iOS
+# or Emscripten, to avoid the need for gas-preprocessor.
+if((HAVE_VLD1_S16_X3 AND HAVE_VLD1_U16_X2 AND HAVE_VLD1Q_U8_X4) OR APPLE OR EMSCRIPTEN)
   set(DEFAULT_NEON_INTRINSICS 1)
 else()
   set(DEFAULT_NEON_INTRINSICS 0)
@@ -301,7 +302,7 @@ if(NEON_INTRINSICS OR BITS EQUAL 32)
   set(SIMD_SOURCES ${SIMD_SOURCES} arm/aarch${BITS}/jchuff-neon.c
     arm/jdcolor-neon.c arm/jfdctint-neon.c)
 endif()
-if(BITS EQUAL 32)
+if(BITS EQUAL 32 OR EMSCRIPTEN)
   set_source_files_properties(${SIMD_SOURCES} COMPILE_FLAGS "-mfpu=neon ${SOFTFP_FLAG}")
 endif()
 if(NOT NEON_INTRINSICS)

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sun, 15 Aug 2021 11:50:00 +0200
Subject: [PATCH 2/2] Revert "Neon/AArch32: Work around Clang T32 miscompilation"

This reverts commit 2a2970a as inline asm won't work for Emscripten.

Upstream-Status: Inappropriate [Emscripten specific]

diff --git a/simd/arm/jchuff.h b/simd/arm/jchuff.h
index 1111111..2222222 100644
--- a/simd/arm/jchuff.h
+++ b/simd/arm/jchuff.h
@@ -74,21 +74,6 @@ typedef struct {
 
 #else
 
-#if defined(_MSC_VER) && !defined(__clang__)
-#define SPLAT() { \
-  buffer[0] = (JOCTET)(put_buffer >> 24); \
-  buffer[1] = (JOCTET)(put_buffer >> 16); \
-  buffer[2] = (JOCTET)(put_buffer >>  8); \
-  buffer[3] = (JOCTET)(put_buffer      ); \
-  buffer += 4; \
-}
-#else
-#define SPLAT() { \
-  put_buffer = __builtin_bswap32(put_buffer); \
-  __asm__("str %1, [%0], #4" : "+r" (buffer) : "r" (put_buffer)); \
-}
-#endif
-
 #define FLUSH() { \
   if (put_buffer & 0x80808080 & ~(put_buffer + 0x01010101)) { \
     EMIT_BYTE(put_buffer >> 24) \
@@ -96,7 +81,8 @@ typedef struct {
     EMIT_BYTE(put_buffer >>  8) \
     EMIT_BYTE(put_buffer      ) \
   } else { \
-    SPLAT(); \
+    *((uint32_t *)buffer) = BUILTIN_BSWAP32(put_buffer); \
+    buffer += 4; \
   } \
 }
 
diff --git a/simd/arm/neon-compat.h.in b/simd/arm/neon-compat.h.in
index 1111111..2222222 100644
--- a/simd/arm/neon-compat.h.in
+++ b/simd/arm/neon-compat.h.in
@@ -27,10 +27,12 @@
 #if defined(_MSC_VER) && !defined(__clang__)
 #define BUILTIN_CLZ(x)  _CountLeadingZeros(x)
 #define BUILTIN_CLZLL(x)  _CountLeadingZeros64(x)
+#define BUILTIN_BSWAP32(x)  _byteswap_ulong(x)
 #define BUILTIN_BSWAP64(x)  _byteswap_uint64(x)
 #elif defined(__clang__) || defined(__GNUC__)
 #define BUILTIN_CLZ(x)  __builtin_clz(x)
 #define BUILTIN_CLZLL(x)  __builtin_clzll(x)
+#define BUILTIN_BSWAP32(x)  __builtin_bswap32(x)
 #define BUILTIN_BSWAP64(x)  __builtin_bswap64(x)
 #else
 #error "Unknown compiler"
